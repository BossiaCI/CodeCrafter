
## Documentation

#### Architecture Globale
L'application s'articule autour de plusieurs composant cl√©s qui communiquent entre eux pour offir une exp√©rience fluide et performante.

1. #### Structure de Modules Principaux
Module Core (core/) - Le coeur de l'application contenant la logique m√©tier fondamentale, incluant l'analyse syntaxique (AST parsing), l'indexation du code, la gestion du contexte projet.

Module LLM (llm/) - L'interface avec les mod√®les de langage (API Claude, mais extensible √† d'autres), g√©rant le streaming, la gestion des tokens, et les retry avec backoff exponentiel.

Module Memory (memory/) - Le syst√®me de m√©moire contextuelle utilisant une base vectorielle (qdrant ou milvus) pour l'embedding et la r√©cup√©ration s√©mantique, avec un cache LRU pour les requ√™tes fr√©quentes.

Module Analysis (analysis/) - Les outils d'analyse statique du code, d√©tection d'erreurs (via clippy pour Rust, eslint pour JS, etc.), calcul de m√©triques de complexit√©, et analyse de d√©pendances.

Module Refactoring (refactoring/) - Les strat√©gies de refactoring automatis√©, la d√©tection de code smell, et les suggestions d'am√©lioration bas√©es sur les patterns.

Module Documentation (docs/) - La g√©n√©ration de documentation avec extraction automatique de commentaires, g√©n√©ration de diagrammes (PlantUML, Mermaid), et cr√©ation de documentation interactive.

Module CLI (cli/) - L'interface en ligne de commande avec parsing des arguments (clap), gestion des commandes interactives, et output format√© avec couleurs.

Module Plugins (plugins/) - Les int√©grations IDE avec protocole LSP (Language Server Protocol) pour VS Code et IntelliJ, webhooks pour √©v√©nements, et syst√®me de plugins extensible.



2. #### Architecture de la M√©moire Contextuelle
Le syst√®me de m√©moire est crucial pour maintenir un contexte coh√©rent. Il fonctionne sur plusieurs niveaux :

Niveau 1 - Cache Court Terme : Stockage en m√©moire RAM des 10 derni√®res interactions avec timestamps et m√©tadonn√©es, acc√®s ultra-rapide (< 1ms).

Niveau 2 - Index Vectoriel : Embeddings de tous les fichiers du projet, requ√™tes s√©mantiques pour retrouver le contexte pertinent, mise √† jour incr√©mentale lors des modifications.

Niveau 3 - Graph de Connaissance : Relations entre fonctions, classes, modules, graphe de d√©pendances traversable, d√©tection de patterns d'utilisation.

Niveau 4 - Historique Persistant : Base SQLite locale pour l'historique des sessions, export/import pour partage d'√©quipe, compression des anciennes donn√©es.


3. #### Flux d'Ex√©cution Typique
Voici comment l'assistant traite une requ√™te utilisateur :

Phase 1 - R√©ception : L'utilisateur soumet une commande via CLI ou IDE. Le parser identifie le type de requ√™te (g√©n√©ration, analyse, refactoring, documentation). Le syst√®me charge le contexte du workspace.

Phase 2 - Analyse Contextuelle : Le module Memory r√©cup√®re les fichiers pertinents via recherche vectorielle. L'AST des fichiers concern√©s est pars√© et analys√©. Le graphe de d√©pendances est construit pour comprendre les relations.

Phase 3 - Enrichissement du Prompt : Le contexte est assembl√© en incluant les fichiers pertinents, l'historique r√©cent, les conventions du projet (d√©tect√©es automatiquement), et les erreurs courantes du projet.

Phase 4 - G√©n√©ration LLM : La requ√™te enrichie est envoy√©e au mod√®le avec streaming pour affichage progressif. Les r√©ponses sont valid√©es syntaxiquement avant pr√©sentation. Les suggestions sont class√©es par pertinence et confiance.

Phase 5 - Post-traitement : Le code g√©n√©r√© est format√© selon les conventions du projet. Les tests sont sugg√©r√©s ou g√©n√©r√©s automatiquement. La documentation inline est ajout√©e. L'index vectoriel est mis √† jour.


4. #### Fonctionnalit√©s Cl√©s

G√©n√©ration de Code Contextuelle : Analyse du style de code existant (naming conventions, patterns architecturaux), respect des types et interfaces existants, suggestions de tests unitaires pertinents, d√©tection automatique du framework/biblioth√®ques utilis√©s.

D√©tection d'Erreurs Avanc√©e : Analyse statique multi-niveaux (syntaxe, s√©mantique, logique), d√©tection de bugs potentiels (null pointer, race conditions), suggestions de corrections avec explication p√©dagogique, int√©gration avec les outils natifs du langage.

Refactoring Intelligent : Extraction de fonctions/m√©thodes avec analyse de port√©e, renommage safe avec v√©rification des r√©f√©rences, simplification de la complexit√© cyclomatique, conversion vers patterns modernes du langage.

Documentation Automatique : G√©n√©ration de README avec description, installation, usage, diagrammes UML g√©n√©r√©s depuis le code (classes, s√©quences, composants), documentation API avec exemples d'utilisation, tutoriels interactifs pour nouveaux contributeurs.

Compr√©hension de Code : Mode "onboarding" pour nouveaux d√©veloppeurs avec parcours guid√© du codebase, visualisation interactive des flux d'ex√©cution, explication en langage naturel de portions complexes, identification des points d'entr√©e et patterns cl√©s.


5. #### Stack Technologique

Langage Principal : Rust (√©dition 2021+) pour performance et s√©curit√© m√©moire.

Parsing & AST : tree-sitter pour parsing multi-langage performant, syn pour parsing Rust sp√©cifique, support de 20+ langages populaires.

Base Vectorielle : qdrant embedded ou milvus lite, fastembed pour g√©n√©ration d'embeddings, dimension 384 ou 768 selon le mod√®le.

CLI : clap v4 pour parsing des arguments, indicatif pour progress bars et spinners, colored pour output format√©.

LSP : tower-lsp pour l'impl√©mentation du protocole, async runtime avec tokio, support WebSocket pour IDE web.

Persistance : SQLite avec sqlx pour historique et cache, serde pour s√©rialisation/d√©s√©rialisation, compression avec zstd.

Tests : proptest pour property-based testing, criterion pour benchmarks de performance, couverture > 80%.


6. #### Interface Utilisateur

##### Mode CLI interactif:

$ codecraft init
‚úì Projet analys√© : 234 fichiers, 45k lignes
‚úì Index cr√©√© : 1,245 embeddings

$ codecraft ask "Comment fonctionne l'authentification ?"
üîç Analyse du contexte...
üìù L'authentification utilise JWT avec refresh tokens.
   Fichiers cl√©s : auth/jwt.rs, middleware/auth.rs
   
   [Diagramme de s√©quence]
   
   Voulez-vous voir le code d√©taill√© ? (o/n)

#### Commandes Principales :

init : Initialise l'assistant dans le projet

ask <question> : Pose une question sur le code

generate <description> : G√©n√®re du nouveau code

refactor <path> : Refactorise un fichier/module

document : G√©n√®re la documentation compl√®te

analyze : Analyse compl√®te avec m√©triques

explain <path> : Explique un fichier en d√©tail

Int√©gration VS Code : Commandes dans la palette (Ctrl+Shift+P), panneau lat√©ral avec arbre de navigation, diagnostics inline avec quick fixes, hover pour explications contextuelles.

Int√©gration IntelliJ : Actions dans le menu Tools, toolwindow d√©di√©e, inspections personnalis√©es, intentions avec Alt+Enter.


7. #### Performance et Scalabilit√©
Optimisations : Traitement parall√®le des fichiers (rayon), indexation incr√©mentale (seulement les fichiers modifi√©s), cache multi-niveaux (m√©moire ‚Üí disque ‚Üí API), compilation en release avec LTO et optimisations agressives.

M√©triques Cibles : Initialisation d'un projet 10k fichiers : < 30s, requ√™te simple avec contexte : < 2s, g√©n√©ration de documentation compl√®te : < 5min, utilisation m√©moire : < 500MB pour projet moyen.